# 크리스마스 프로모션

> 우테코 식당의 크리스마스 프로모션을 관리하는 프로그램입니다.
> 사용자에게 날짜와 메뉴를 입력받아 이벤트에서 어떤 혜택을 받을 수 있는지 알려줍니다.

# 기능 목록

## 입력

- [x] 방문할 날짜 입력
  - [x] 숫자가 아닐경우 예외 발생, 재입력
- [x] 주문할 메뉴와 개수 입력
  - [x] 빈 문자열일 경우 예외 발생, 재입력

## 유틸

- [x] 입력값 파싱 : InputParser
  - [x] 날짜 파싱
    - [x] 자연수가 아닐 경우 "[ERROR] 유효하지 않은 날짜입니다. 다시 입력해 주세요." 출력하고 재입력
  - [x] 메뉴 파싱
    - [x] 메뉴 형식이 예시와 다를 경우 "[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요." 출력하고 재입력

## 도메인

- [x] 메뉴 카테고리 열거형 : MenuCategory
- [x] 메뉴 열거형 : Menu
  - 이름, 금액
- [x] 이벤트 열거형 : Event
  - 이름, 적용날짜, 적용기간, 적용메뉴, 할인가격 등 모든 이벤트 어떻게 적용되는지 계산가능
- [x] 배지 열거형 : Badge
  - 금액으로 알맞은 배지 반환

- [x] 문자열 Enum 으로 변환 : MenuService 

- [x] 입력 날짜 객체 : Date
  - 날짜 유효성 보증 책임
    - 예외 발생시 "[ERROR] 유효하지 않은 날짜입니다. 다시 입력해 주세요." 출력하고 재입력
    - [x] 1~31의 숫자 아닐 경우
- [x] 주문한 메뉴 객체 : Order
  - 저장된 메뉴의 총액 계산 기능
  - 메뉴 유효성 보증 책임
    - 예외 발생시 "[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요." 출력하고 재입력
    - [x] 메뉴판에 없는 메뉴를 입력할 경우
    - [x] 메뉴 개수 1 이상의 숫자가 아닐 경우
    - [x] 중복 메뉴 입력할 경우
    - [x] 음료만 주문 불가능
    - [x] 메뉴 최대 20개까지 가능
- [x] 적용된 이벤트 객체 : AppliedEvents
  - 정적 팩터리 메서드
  - 어떤 Event의 할인이 얼마나 적용되었는지 한번에 저장하는 객체
  - 적용된 이벤트의 총액 계산 책임
  - 총액이 10000 이상일 때만 이벤트 적용


## 출력

- [x] 주문 메뉴 출력
- [x] 할인 전 총주문 금액 출력
- [x] 증정 메뉴 출력
- [ ] 혜택 내역 출력
  - 모든 적용 이벤트 출력
- [ ] 총혜택 금액 출력
- [ ] 할인 후 예상 결제 금액 출력
- [ ] 12월 이벤트 베지 출력


## 학습 목표

> 클래스(객체)를 분리하는 연습

1. 클래스의 역할과 책임을 생각해 보고
2. 도메인 로직에 집중하는 방향으로 구현
3. UI는 도메인 로직과 분리
   - View 에서 사용할 데이터는 getter로 데이터 전달
   - 연관성이 있는 상수는 static final 대신 enum 활용
   - 불면 값은 final 로 변경 막기
   - 데이터를 꺼내지 말고, 메세지를 던지도록 구조를 바꿔서 데이터를 가지는 객체가 일하도록
     - [참고](https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/)
   - 필드 (인스턴스 변수)가 많으면 복잡도가 높아 버그 발생 가능성이 높아지므로 줄이기 위해 노력하기.
   - 예외 상황 잘 찾아서 테스트 하기
   - 메소드 분리는 가독성 상승에 좋다. 성능이 떨어져도 된다


## 리팩토링

- [ ] 정적 팩토리 메서드 써보기
- [ ] 테스트 코드 개선하기
- [ ] 문자열 래핑

## 문제해결

### 객체의 역할

사용자의 메뉴 입력 정보가 분석되는 단계이다.

1. 문자열 -> 기본 입력 검증 (빈 문자열 등)
2. 기본 검증된 문자열 -> 입력 형식에 올바른지 검증
3. 입력 형식 검증된 문자열 -> List<String, Integer>
4. List<String, Integer> -> List<Menu, Integer>
5. List<Menu, Integer> -> Order 객체

이 모든 기능을 도메인, View, Controller, domain, Util 등 어떤 패키지에서 어떤 클래스가 동작해야하는지 생각해봤다.

1. 문자열 -> 기본입력 검증 (빈 문자열, 숫자가 아닌 경우 등)

입력이 뷰에서 들어오기 때문에 아주 기본적인 검증은 뷰의 역할이라고 생각했다.

2. 기본 검증된 문자열 -> 입력 형식에 올바른지 검증

입력 형식이라는 것은 비즈니스 로직과는 무관하다고 볼 수 있고,
비즈니스 로직은 그대로지만 입력 형식을 바꾸고 싶을때,
도메인 영역을 건들지 않고 수정할 수 있게 하기위해 util 패키지 - InputParser 의 역할로 했다.

3. 입력 형식 검증된 문자열 -> List<String, Integer>

이것도 마찬가지 입력 형식을 구조화 하는것은 util 패키지 - InputParser의 역할이다.

4. List<String, Integer> -> List<Menu, Integer>

이 부분은 문자열을 Menu 라는 도메인 객체로 만드므로 컨트롤러 또는 서비스 계층의 역할이다.
컨트롤러에 구현하면 컨트롤러의 역할이 너무 많아질 것 같으므로 서비스 클래스에 맡기기로 했다.

5. List<Menu, Integer> -> Order 객체

직접적인 Order 객체 생성 도메인의 책임이므로,
Order 객체 내부의 생성자 또는 팩토리 메소드에서 수행하기로 했다.

###
