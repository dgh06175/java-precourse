# 자동차 경주

## 기능 목록

- 게임 세팅
  - [x] 자동차 이름 입력 안내 문구 출력
  - [x] 자동차 이름 입력
  - [x] 시도할 횟수 입력 안내 문구 출력
  - [x] 시도할 횟수 입력

- 게임 로직 처리
  - [x] 무작위 숫자 생성
  - [x] 차수 마다 자동차 전진 명령
  - [x] 자동차 무작위로 전진
  - [x] 차수 실행 결과(자동차의 위치) 분석
  - [x] 차수 실행 결과 출력
  - [x] 차수 횟수 도달시 게임 종료

- 게임 종료시
  - [x] 가장 멀리 간 자동차들 판별
  - [x] 우승자 안내 문구 출력

- 예외 처리
  - [x] 자동차 이름 입력
  - [x] 시도할 횟수 입력



## 해야할 일


- [x] TDD 학습
- [x] 피드백 받은것 학습
- [x] 클래스 다이어그램 그리기
  <br><img src="https://drive.google.com/uc?export=download&id=1dyQl5DYD31gapDS3C51iSa2HAisS4Wtc"/><br>
- [x] 테스트 코드 추가
- [x] 구현
- [ ] 객체지향 생활체조 원칙 적용
  - [ ] 한 메소드에 오직 한 단계의 들여쓰기(indent)만 한다.
  - [ ] else 예약어를 쓰지 않는다.
  - [ ] 모든 원시값과 문자열을 포장한다.
  - [ ] 한 줄에 점을 하나만 찍는다.
  - [ ] 줄여쓰지 않는다(축약 금지).
  - [ ] 모든 엔티티를 작게 유지한다.
  - [ ] 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
  - [ ] 일급 컬렉션을 쓴다.
  - [ ] 게터/세터/프로퍼티를 쓰지 않는다. 단, DTO는 허용한다.
  - [ ] 메소드의 인자 수를 최대 3개만 사용한다. 적을 수록 좋다.
  - [ ] 메소드가 한가지 일만 담당하도록 구현.
  - [ ] 클래스를 작게 유지하기 위해 노력. 50줄 이상이면 여러가지 일을 동시에 하고 있을 확률이 높다.
  - [ ] 메서드당 line을 10까지만 허용. 길이가 길어지면 메서드로 분리
  - [ ] 매직 리터럴 / 매직 넘버 사용을 자제하고 상수 사용

## 파일 구조

```
racingcar
├── Application.java
├── controller
│   └── RacingGameController.java : 게임 실행
├── domain
│   ├── GameResultAnalyzer.java : 게임 결과 분석
│   ├── RacingCar.java : 자동차 클래스
│   └── RandomNumberGenerator.java : 무작위 숫자 생성
├── exception
│   └── InvalidInputException.java : 유저 입력 예외 
└── ui
    ├── InputView.java : 화면 출력
    └── OutputView.java : 유저 입력
```

### 피드백

- static 함수는 끝까지 메모리에 남아있고, 전역에서 접근 가능하므로 객체지향적이지 않으므로 꼭 필요한거 아니면 자제하자.
- List<클래스> 대신 일급 컬렉션 사용.
- 컨트롤러의 역할은 해당 클래스에 입력값 전달, 게임 시작 메시지 전송, 결과를 받아 출력 정도
- 랜덤 관련 함수는 테스트 하기 힘드니, 숫자 생성 인터페이스르 만들고, 해당 인터페이스를 구현하 랜덤 숫자 생성 구현체를 실제 코드에 사용, 내가 원하는 숫자 구현체를 테스트에 사용하자.
  - [자동차 경주 게임 깃허브 링크](https://github.com/next-step/java-racingcar/pull/4677/files#diff-a5219fe627362cc5231955d2894bef48b8bdf9da497868b9fdace7622b7b7231)
    에서 Car, Engine, CarTest 보고, "의존성 주입" 이라는 키워드로 학습하기

### 문제해결과정

1. 테스트가 쉽도록 리팩토링 하기
  - 랜덤값을 메소드 안에서 돌려버리면 테스트 하기 어렵다. 
  - 해결방법1 : 랜덤으로 나온 값을 매개변수로 받아서 동작하는 메소드로 만들면 테스트 하기 쉬워진다. 
  - 해결방법2 : 숫자 생성 인터페이스를 구현해서 사용 클래스에서 구현체를 만들어서 실제 코드와 테스트 코드에서 다르게 사용한다.
  - '의존성 주입' 에 대해 학습하고 블로그에 정리했다. [링크](https://velog.io/@dgh06175/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85)

2. 입력값 검증의 책임 
  - InputView 에서는 기본적인 입력값 검증에 대한 책임이 있는게 확실해 보인다. (공백, 형식에 맞지 않는 입력 등)
  - 그런데, 비즈니스 로직에 대한 검증의 책임은 누구한테 있는것일까? (길이 5자 이내, 1~9사이 등)
  - 이름이 5자 안쪽이여야 한다는건 Car 때문에 생긴 제약일까 아니면 자동차 외부에서 정해진 규칙일까? 
  - 자동차에 이름을 새기려면 너무 길면 안되기 때문에 글자수 제한이 생긴거라고 생각하면, 
  - RacingCar 생성시에 이름을 전달받고, 생성자에서 검증 로직을 구현하는것이 좋아보인다. 
  - 하지만, 생성자에서 특정 로직을 수행 하는것은 좋지 못하다. 
  - 해결방법 1. Name 클래스를 구현해서 이름 글자수 검증에 대한 책임을 이전하는 것이다. 하지만 이 경우 불필요한 코드만 많아지는 느낌이다. 
  - 해결방법 2. 컨트롤러에서 검증을 수행한 후 오류가 발생하지 않는 이름으로 RacingCar에게 전달한다. 다른 도메인 로직에 validator 클래스를 구현한 후 컨트롤러에서 이름 검증을 해서 전달한다. 
  - 일단 생성자에서 로직 수행하는걸로 구현하자..

3. 올바른 객체지향
  - [참고](https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/) [참고2](https://www.slipp.net/questions/559) [참고3](https://www.slipp.net/questions/565)
  - [토스ㅣSLASH 21 - 실무에서 바로 쓰는 Frontend Clean Code](https://www.youtube.com/watch?v=edWbHp_k_9Y&t=25s)
  - 위 영상과 글들, **객체지향의 사실과 오해**, 그리고 **Clean Code** 을 보고, 
  - 객체지향의 올바른 설계와 TDD 방법론을 따르기 위해, 코드를 모두 갈아엎고 설계 단계부터 다시 시작하기로 했다.

> - 목표 1. 모든 객체가 서로 협력할떄, 메세지를 전달하고 전달받으며 세부 로직은 서로 모르는 상태가 되는 것.
> - 목표 2. 테스트가 용이하도록 구현하기 위해 코드 구현하기 전에 단위 테스트를 먼저 작성

  - 먼저, 간단한 클래스 다이어그램을 그려서 객체들의 역할에 대해 정리했다.
